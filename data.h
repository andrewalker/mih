
/* Exported state machine variables (142)*/

/* TID (TID): A transaction identifier*/
int _tid;       /* local Transaction ID*/

/* MyMihfID (MIHF_ID): The MIHF ID of this MIH node*/
unsigned char _mymihfid[MIH_ID_LEN];  /* MIHF Identifier*/

/* PeerMihfID (MIHF_ID): The MIHF ID of the peer MIH node*/
unsigned char _peermihfid[MIH_ID_LEN];  /* MIHF Identifier*/

/* MsgIn (MIH_MESSAGE): A valid incoming message received from a remote MIHF.*/
/* Already unpacked into a mih_message_t structure*/
mih_message_t _msgin;

/* MsgInAvail (BOOLEAN): set to TRUE when a valid incoming message is*/
/*    available for a transaction*/
boolean_t _msginavail = 0; /* FALSE*/

/* MsgOut (MIH_MESSAGE): valid outgoing message generated by the local MIHF*/
/* to be sent to the remote MIHF. NOT yet serialized for transmission*/
mih_message_t _msgout;

/* MsgOutAvail (BOOLEAN): set to TRUE when a valid outgoing message is*/
/*    available for a transaction*/
boolean_t _msgoutavail = 0; /* FALSE*/

/* TransactionStatus (ENUMERATED): indicates the status of the transaction.*/
/*    1 ONGOING, 2 SUCCESS, 3 FAILURE*/
/*
enum {
	ONGOING = 1,
	SUCCESS = 2,
	FAILURE = 3
} _transactionstatus = SUCCESS;
*/
unsigned char _transactionstatus = SUCCESS;

/* StartAckRequestor (BOOLEAN):*/
boolean_t _startackrequestor = 0; /* FALSE*/
/* StartAckResponder (BOOLEAN):*/
boolean_t _startackresponder = 0; /* FALSE*/



/* capabilities supported (F.20 / pp 249)*/

/* list of events services supported*/
mih_evt_list_t     _evt_list = 0 \
	| MIH_LINK_DETECTED_CAP \
	| MIH_LINK_UP_CAP \
	| MIH_LINK_DOWN_CAP \
	| MIH_LINK_PARAMETERS_REPORT_CAP \
	| MIH_LINK_GOING_DOWN_CAP \
	| MIH_LINK_HANDOVER_IMMINENT_CAP \
	| MIH_LINK_HANDOVER_COMPLETE_CAP \
	| MIH_LINK_PDU_TRANSMIT_STATUS_CAP \
	;

/* list of commands services supported*/
mih_cmd_list_t     _cmd_list = 0 \
	| MIH_LINK_GET_PARAMETERS_CAP \
	| MIH_LINK_CONFIGURE_THRESHOLDS_CAP \
	| MIH_LINK_ACTIONS_CAP \
	| MIH_NET_HO_CANDIDATE_QUERY_CAP \
	| MIH_NET_HO_COMMIT_CAP \
	| MIH_N2N_HO_QUERY_RESOURCES_CAP \
	| MIH_N2N_HO_COMMIT_CAP \
	| MIH_N2N_HO_COMPLETE_CAP \
	| MIH_MN_HO_CANDIDATE_QUERY_CAP \
	| MIH_MN_HO_COMMIT_CAP \
	| MIH_MN_HO_COMPLETE_CAP \
	;

/* list of information services supported*/
mih_iq_type_lst_t  _iq_type_lst = 0;
/*
	/* | BINARY_DATA_CAP \*/
	/* | RDF_DATA_CAP \*/
	/* | RDF_SCHEMA URL_CAP \*/
	/* | RDF_SCHEMA_CAP \*/
	/* | IE_NETWORK_TYPE_CAP \*/
	/* | IE_OPERATOR_ID_CAP \*/
	/* | IE_SERVICE_PROVIDER_ID_CAP \*/
	/* | IE_COUNTRY_CODE_CAP \*/
	/* | IE_NETWORK_ID_CAP \*/
	/* | IE_NEWORK_AUX_ID_CAP \*/
	/* | IE_ROAMING_PARTNERS_CAP \*/
	/* | IE_COST_CAP \*/
	/* | IE_NETWORK_QOS_CAP \*/
	/* | IE_NETWORK_DATE_RATE_CAP \*/
	/* | IE_NET_REGULT_DOMAIN_CAP \*/
	/* | IE_NET_FREQUENCY_BANDS_CAP \*/
	/* | IE_NET_IP_CFG_METHODS_CAP \*/
	/* | IE_NET_CAPABILITIES_CAP \*/
	/* | IE_NET_SUPPORTED_LCP_CAP \*/
	/* | IE_NET_MOB_MGMT_PROT_CAP \*/
	/* | IE_NET_EMSERV_PROXY_CAP \*/
	/* | IE_NET_IMS_PROXY_CSCF_CAP \*/
	/* | IE_NET_MOBILE_NETWORK_CAP \*/
	/* | IE_POA_LINK_ADDR_CAP \*/
	/* | IE_POA_LOCATION_CAP \*/
	/* | IE_POA_CHANNEL_RANGE_CAP \*/
	/* | IE_POA_SYSTEM_INFO_CAP \*/
	/* | IE_POA_SUBNET_INFO_CAP \*/
	/* | IE_POA_IP_ADDR_CAP \*/
	/* ;*/
*/

/* list of supported transports*/
mih_trans_lst_t  _trans_lst = UDP_CAP | TCP_CAP;

/* (249)*/
/* link_det_cfg*/
/* Information of a detected link (249)*/
/* link_det_info*/

/* Other variables of interest (Helio)*/
/**/
/* PreferredTransport*/
/* SubscribedEvents: list of LINK events to which the local MIHF has subscribed*/
/* EventSubscribers: list of MIHF entities who have subscribed to local events*/
/* RegisteredUsers: List of Remote MIHFs registered to this MIHF*/
/* RegisteredMihfs: List of Remote MIHFs to whom the local MIHF has registered*/

/* frequently used TLVs*/
/* mih_tlv_t _mymihfid_tlv;    // TLV structure for the SOURCE MIHF ID*/
/* mih_tlv_t _peermihfid_tlv;  // TLV structure for the DESTINATION MIHF ID*/

/* Payload length: 16 bits (<=64KB)*/
/* Fragmentation MUST be left to TCP and UDP when transfering data above L3.*/
/* Keep buffer smaller than the MSS and control fragmentation (1460)?*/
#define SNDBUF_SZ	 65487     /* 65535 -20 -20 -8*/
#define RCVBUF_SZ	 65487     /* 65535 -20 -20 -8*/

/* Default MIHF to register to*/
/* Should be obtained from a DNS query (getaddrinfo using MIHF port 4551)*/
#define DFL_MIHF		"localhost"

/* indicates wether the MIH start up function has been run*/
int _mih_init_done=0;

/* input and output buffers are defined as global variables...*/
/* used to pack any PDU to send*/
/* what if a confirmed PDU was sent and still not confirmed and*/
/* there's a new transmission request?*/
/* there can be only one outstanding request (_msgout)*/

/* unsigned char _snd_buff[SNDBUF_SZ];	// sending buffer*/
/* unsigned char _rcv_buff[RCVBUF_SZ];	// receiving buffer*/
unsigned char *_snd_buf;	/* sending buffer - must be (k)malloc-ed*/
unsigned char *_rcv_buf;	/* receiving buffer - must be (k)free-ed*/

/* maximum number os socket descriptors allowed in the poll structure*/
#define MAX_FDS 4
/* indexes for the poll structure*/
#define TCP4	0
#define UDP4	1
#define TCP6	2
#define UDP6	3

/* socket descriptors for incomming data - user space app only...*/
struct pollfd _fds[MAX_FDS];

/* information about the peer MIHF with which we have registered*/
/* struct addrinfo    _mih_peer_addr;    // peer MIHF's socket address*/
struct sockaddr_in _mih_peer_addr;       /* peer MIHF's socket address*/


/* Information element containers (49)*/
/**/
/* IE_CONTAINER_LIST_OF_NETWORKS: list of neighboring Access Network Containers*/
/* IE_CONTAINER_NETWORK: information that depicts an access network*/
/* IE_CONTAINER_POA: information that depicts a PoA*/

/* List of neighboring Access Network Containers, containing information that*/
/* depicts a list of heterogeneous neighboring access networks for a given*/
/* geographical location*/
/* Each network is associated with an operator, and each network may have several PoAs*/
ie_container_network_t *_list_of_networks = NULL;


/* Information about local links/interfaces*/
/* Should we replicate this or access the kernel list whenever needed?*/
struct dev_list {
	struct net_device *dev;
	struct dev_list   *next;
};
struct dev_list *_local_devs = NULL;


/* List of subscribers and thresholds (parameters)...*/
struct subscriber {
	mihf_id_t          mihfid;
	mih_trans_lst_t    trans_lst;  /* list of supported transport protocol*/
	struct sockaddr    addr;       /* peer MIHF's socket address*/
	link_type_t        link;       /* interface (monitored interface?)*/
	mih_evt_list_t     evt_list;   /* bitmap list of subscribed events*/
	link_cfg_param_t   param;      /* parameters to monitor*/
	struct subscriber * next;
} *_subscribers = NULL,
  *_subscriptions = NULL;

/* information about events to which we have subscribed (bitmap + pointer vector)*/
/* Does this require modifying the API to introduce a callback function*/
/* and parameters (can be NULL)?*/

