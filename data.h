
/* Exported state machine variables (142) */

/* TID (TID): A transaction identifier */
int _tid;       /* local Transaction ID */

/* MyMihfID (MIHF_ID): The MIHF ID of this MIH node */
unsigned char _mymihfid[] = "mihf1";  /* MIHF Identifier */

/* PeerMihfID (MIHF_ID): The MIHF ID of the peer MIH node */
unsigned char _peermihfid[MIH_ID_LEN];  /* MIHF Identifier */

/* MsgIn (MIH_MESSAGE): A valid incoming message received from a remote MIHF. */
/* Already unpacked into a mih_message_t structure */
mih_message_t _msgin;

/* MsgInAvail (BOOLEAN): set to TRUE when a valid incoming message is */
/*    available for a transaction */
boolean_t _msginavail = 0; /* FALSE */

/* MsgOut (MIH_MESSAGE): valid outgoing message generated by the local MIHF */
/* to be sent to the remote MIHF. NOT yet serialized for transmission */
mih_message_t _msgout;

/* MsgOutAvail (BOOLEAN): set to TRUE when a valid outgoing message is */
/*    available for a transaction */
boolean_t _msgoutavail = 0; /* FALSE */

/* TransactionStatus (ENUMERATED): indicates the status of the transaction. */
/*    1 ONGOING, 2 SUCCESS, 3 FAILURE */
/*
enum {
	ONGOING = 1,
	SUCCESS = 2,
	FAILURE = 3
} _transactionstatus = SUCCESS;
*/
unsigned char _transactionstatus = SUCCESS;

/* StartAckRequestor (BOOLEAN): */
boolean_t _startackrequestor = 0; /* FALSE */
/* StartAckResponder (BOOLEAN): */
boolean_t _startackresponder = 0; /* FALSE */



/* capabilities supported (F.20 / pp 249) */

/* list of events services supported */
mih_evt_list_t _evt_list = {
	.MIH_Link_Detected		= 1,
	.MIH_Link_Up			= 1,
	.MIH_Link_Down			= 1,
	.MIH_Link_Parameters_Report	= 1,
	.MIH_Link_Going_Down		= 1,
	.MIH_Link_Handover_Imminent	= 1,
	.MIH_Link_Handover_Complete	= 1,
	.MIH_Link_PDU_Transmit_Status	= 1
};

/* list of commands services supported */
mih_cmd_list_t _cmd_list = {
	.MIH_Link_Get_Parameters	= 1,
	.MIH_Link_Configure_Thresholds	= 1,
	.MIH_Link_Actions		= 1,
	.MIH_Net_HO_Candidate_Query	= 1,
	/* .MIH_Net_HO_Commit		= 1,
	 * .MIH_N2N_HO_Query_Resources	= 1,
	 * .MIH_N2N_HO_Commit		= 1,
	 * .MIH_N2N_HO_Complete		= 1,
	 */
	.MIH_MN_HO_Candidate_Query	= 1,
	/* .MIH_MN_HO_Commit		= 1,
	 * .MIH_MN_HO_Complete		= 1
	 */
};

/* list of information services supported */
mih_iq_type_lst_t _iq_type_lst = {
	.Binary_Data			= 0,
	.RDF_Data			= 0,
	.RDF_Schema_URL			= 0,
	.RDF_Schema			= 0,
	.IE_Network_Type			= 0,
	.IE_Operator_ID			= 0,
	.IE_Service_Provider_ID		= 0,
	.IE_Country_Code			= 0,
	.IE_Network_ID			= 0,
	.IE_Nework_Aux_ID		= 0,
	.IE_Roaming_Partners		= 0,
	.IE_Cost				= 0,
	.IE_Network_QoS			= 0,
	.IE_Network_Date_Rate		= 0,
	.IE_Net_Regult_Domain		= 0,
	.IE_Net_Frequency_bands		= 0,
	.IE_Net_IP_Cfg_Methods		= 0,
	.IE_Net_Capabilities		= 0,
	.IE_Net_Supported_LCP		= 0,
	.IE_Net_Mob_Mgmt_Prot		= 0,
	.IE_Net_Emserv_Proxy		= 0,
	.IE_Net_IMS_Proxy_CSCF		= 0,
	.IE_Net_Mobile_Network		= 0,
	.IE_PoA_Link_Addr		= 0,
	.IE_PoA_Location			= 0,
	.IE_PoA_Channel_Range		= 0,
	.IE_PoA_System_Info		= 0,
	.IE_PoA_Subnet_Info		= 0,
	.IE_PoA_IP_Addr			= 0
};

/* list of supported transports */
mih_trans_lst_t _trans_lst = {
	.UDP				= 0,
	.TCP				= 1
};

/* (249) */
/* link_det_cfg */
/* Information of a detected link (249) */
/* link_det_info */

/* Other variables of interest (Helio) */
/* */
/* PreferredTransport */
/* SubscribedEvents: list of LINK events to which the local MIHF has subscribed */
/* EventSubscribers: list of MIHF entities who have subscribed to local events */
/* RegisteredUsers: List of Remote MIHFs registered to this MIHF */
/* RegisteredMihfs: List of Remote MIHFs to whom the local MIHF has registered */

/* frequently used TLVs */
/* mih_tlv_t _mymihfid_tlv;    // TLV structure for the SOURCE MIHF ID */
/* mih_tlv_t _peermihfid_tlv;  // TLV structure for the DESTINATION MIHF ID */

/* Payload length: 16 bits (<=64KB) */
/* Fragmentation MUST be left to TCP and UDP when transfering data above L3. */
/* Keep buffer smaller than the MSS and control fragmentation (1460)? */
#define SNDBUF_SZ	 65487     /* 65535 -20 -20 -8 */
#define RCVBUF_SZ	 65487     /* 65535 -20 -20 -8 */

/* Default MIHF to register to */
/* Should be obtained from a DNS query (getaddrinfo using MIHF port 4551) */
#define DFL_MIHF		"localhost"

/* indicates wether the MIH start up function has been run */
int _mih_init_done=0;

/* input and output buffers are defined as global variables... */
/* used to pack any PDU to send */
/* what if a confirmed PDU was sent and still not confirmed and */
/* there's a new transmission request? */
/* there can be only one outstanding request (_msgout) */

/* unsigned char _snd_buff[SNDBUF_SZ];	// sending buffer */
/* unsigned char _rcv_buff[RCVBUF_SZ];	// receiving buffer */
unsigned char *_snd_buf;	/* sending buffer - must be (k)malloc-ed */
unsigned char *_rcv_buf;	/* receiving buffer - must be (k)free-ed */

/* maximum number os socket descriptors allowed in the poll structure */
#define MAX_FDS 4
/* indexes for the poll structure */
#define TCP4	0
#define UDP4	1
#define TCP6	2
#define UDP6	3

/* socket descriptors for incomming data - user space app only... */
struct pollfd _fds[MAX_FDS];

/* information about the peer MIHF with which we have registered */
/* struct addrinfo    _mih_peer_addr;    // peer MIHF's socket address */
struct sockaddr_in _mih_peer_addr;       /* peer MIHF's socket address */


/* Information element containers (49) */
/* */
/* IE_CONTAINER_LIST_OF_NETWORKS: list of neighboring Access Network Containers */
/* IE_CONTAINER_NETWORK: information that depicts an access network */
/* IE_CONTAINER_POA: information that depicts a PoA */

/* List of neighboring Access Network Containers, containing information that */
/* depicts a list of heterogeneous neighboring access networks for a given */
/* geographical location */
/* Each network is associated with an operator, and each network may have several PoAs */
ie_container_network_t *_list_of_networks = NULL;


/* Information about local links/interfaces */
/* Should we replicate this or access the kernel list whenever needed? */
struct dev_list {
	struct net_device *dev;
	struct dev_list   *next;
};
struct dev_list *_local_devs = NULL;


/* List of subscribers and thresholds (parameters)... */
struct subscriber {
	mihf_id_t          mihfid;
	mih_trans_lst_t    trans_lst;  /* list of supported transport protocol */
	struct sockaddr    addr;       /* peer MIHF's socket address */
	link_type_t        link;       /* interface (monitored interface?) */
	mih_evt_list_t     evt_list;   /* bitmap list of subscribed events */
	link_cfg_param_t   param;      /* parameters to monitor */
	struct subscriber * next;
} *_subscribers = NULL,
  *_subscriptions = NULL;

/* information about events to which we have subscribed (bitmap + pointer vector) */
/* Does this require modifying the API to introduce a callback function */
/* and parameters (can be NULL)? */

